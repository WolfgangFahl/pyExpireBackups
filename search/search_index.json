{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyExpireBackups API Documentation","text":""},{"location":"#expirebackups.expire","title":"<code>expire</code>","text":"<p>Created on 2022-04-01</p> <p>@author: wf</p>"},{"location":"#expirebackups.expire.BackupFile","title":"<code>BackupFile</code>","text":"<p>a Backup file which is potentially to be expired</p> Source code in <code>expirebackups/expire.py</code> <pre><code>class BackupFile:\n    \"\"\"\n    a Backup file which is potentially to be expired\n    \"\"\"\n\n    def __init__(self, filePath: str):\n        \"\"\"\n        constructor\n\n        Args:\n            filePath(str): the filePath of this backup File\n        \"\"\"\n        self.filePath = filePath\n        self.modified, self.size = self.getStats()\n        self.sizeValue, self.unit, self.factor = BackupFile.getSize(self.size)\n        self.sizeString = BackupFile.getSizeString(self.size)\n        self.ageInDays = self.getAgeInDays()\n        self.isoDate = self.getIsoDateOfModification()\n        self.expire = False\n\n    def __str__(self):\n        \"\"\"\n        return a string representation of me\n        \"\"\"\n        text = f\"{self.ageInDays:6.1f} days {self.getMarker()}({self.sizeString}):{self.filePath}\"\n        return text\n\n    def getMarker(self):\n        \"\"\"\n        get my marker\n\n        Returns:\n            str: a symbol \u274c if i am to be deleted a \u2705 if i am going to be kept\n        \"\"\"\n        marker = \"\u274c\" if self.expire else \"\u2705\"\n        return marker\n\n    @classmethod\n    def getSizeString(cls, size: float) -&gt; str:\n        \"\"\"\n        get my Size in human readable terms as a s\n\n        Args:\n            size(float): Size in Bytes\n\n        Returns:\n            str: a String representation\n        \"\"\"\n        size, unit, _factor = cls.getSize(size)\n        text = f\"{size:5.0f} {unit}\"\n        return text\n\n    @classmethod\n    def getSize(cls, size: float) -&gt; Tuple[float, str, float]:\n        \"\"\"\n        get my Size in human readable terms\n\n        Args:\n            size(float): Size in Bytes\n\n        Returns:\n            Tuple(float,str,float): the size, unit and factor of the unit e.g. 3.2, \"KB\", 1024\n        \"\"\"\n        units = [\" B\", \"KB\", \"MB\", \"GB\", \"TB\"]\n        unitIndex = 0\n        factor = 1\n        while size &gt; 1024:\n            factor = factor * 1024\n            size = size / 1024\n            unitIndex += 1\n        return size, units[unitIndex], factor\n\n    def getStats(self) -&gt; Tuple[datetime.datetime, float]:\n        \"\"\"\n        get the datetime when the file was modified\n\n        Returns:\n            datetime: the file modification time\n        \"\"\"\n        stats = os.stat(self.filePath)\n        modified = datetime.datetime.fromtimestamp(stats.st_mtime, tz=datetime.timezone.utc)\n        size = stats.st_size\n        return modified, size\n\n    def getAgeInDays(self) -&gt; float:\n        \"\"\"\n        get the age of this backup file in days\n\n        Returns:\n            float: the number of days this file is old\n        \"\"\"\n        now = datetime.datetime.now(tz=datetime.timezone.utc)\n        age = now - self.modified\n        return age.days\n\n    def getIsoDateOfModification(self):\n        \"\"\"\n        get the data of modification as an ISO date string\n\n        Returns:\n            str: an iso representation of the modification date\n        \"\"\"\n        isoDate = self.modified.strftime(\"%Y-%m-%d_%H:%M\")\n        return isoDate\n\n    def delete(self):\n        \"\"\"\n        delete my file\n        \"\"\"\n        if os.path.isfile(self.filePath):\n            os.remove(self.filePath)\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.__init__","title":"<code>__init__(filePath)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>filePath(str)</code> <p>the filePath of this backup File</p> required Source code in <code>expirebackups/expire.py</code> <pre><code>def __init__(self, filePath: str):\n    \"\"\"\n    constructor\n\n    Args:\n        filePath(str): the filePath of this backup File\n    \"\"\"\n    self.filePath = filePath\n    self.modified, self.size = self.getStats()\n    self.sizeValue, self.unit, self.factor = BackupFile.getSize(self.size)\n    self.sizeString = BackupFile.getSizeString(self.size)\n    self.ageInDays = self.getAgeInDays()\n    self.isoDate = self.getIsoDateOfModification()\n    self.expire = False\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.__str__","title":"<code>__str__()</code>","text":"<p>return a string representation of me</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    return a string representation of me\n    \"\"\"\n    text = f\"{self.ageInDays:6.1f} days {self.getMarker()}({self.sizeString}):{self.filePath}\"\n    return text\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.delete","title":"<code>delete()</code>","text":"<p>delete my file</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def delete(self):\n    \"\"\"\n    delete my file\n    \"\"\"\n    if os.path.isfile(self.filePath):\n        os.remove(self.filePath)\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getAgeInDays","title":"<code>getAgeInDays()</code>","text":"<p>get the age of this backup file in days</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the number of days this file is old</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getAgeInDays(self) -&gt; float:\n    \"\"\"\n    get the age of this backup file in days\n\n    Returns:\n        float: the number of days this file is old\n    \"\"\"\n    now = datetime.datetime.now(tz=datetime.timezone.utc)\n    age = now - self.modified\n    return age.days\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getIsoDateOfModification","title":"<code>getIsoDateOfModification()</code>","text":"<p>get the data of modification as an ISO date string</p> <p>Returns:</p> Name Type Description <code>str</code> <p>an iso representation of the modification date</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getIsoDateOfModification(self):\n    \"\"\"\n    get the data of modification as an ISO date string\n\n    Returns:\n        str: an iso representation of the modification date\n    \"\"\"\n    isoDate = self.modified.strftime(\"%Y-%m-%d_%H:%M\")\n    return isoDate\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getMarker","title":"<code>getMarker()</code>","text":"<p>get my marker</p> <p>Returns:</p> Name Type Description <code>str</code> <p>a symbol \u274c if i am to be deleted a \u2705 if i am going to be kept</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getMarker(self):\n    \"\"\"\n    get my marker\n\n    Returns:\n        str: a symbol \u274c if i am to be deleted a \u2705 if i am going to be kept\n    \"\"\"\n    marker = \"\u274c\" if self.expire else \"\u2705\"\n    return marker\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getSize","title":"<code>getSize(size)</code>  <code>classmethod</code>","text":"<p>get my Size in human readable terms</p> <p>Parameters:</p> Name Type Description Default <code>size(float)</code> <p>Size in Bytes</p> required <p>Returns:</p> Name Type Description <code>Tuple</code> <code>(float, str, float)</code> <p>the size, unit and factor of the unit e.g. 3.2, \"KB\", 1024</p> Source code in <code>expirebackups/expire.py</code> <pre><code>@classmethod\ndef getSize(cls, size: float) -&gt; Tuple[float, str, float]:\n    \"\"\"\n    get my Size in human readable terms\n\n    Args:\n        size(float): Size in Bytes\n\n    Returns:\n        Tuple(float,str,float): the size, unit and factor of the unit e.g. 3.2, \"KB\", 1024\n    \"\"\"\n    units = [\" B\", \"KB\", \"MB\", \"GB\", \"TB\"]\n    unitIndex = 0\n    factor = 1\n    while size &gt; 1024:\n        factor = factor * 1024\n        size = size / 1024\n        unitIndex += 1\n    return size, units[unitIndex], factor\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getSizeString","title":"<code>getSizeString(size)</code>  <code>classmethod</code>","text":"<p>get my Size in human readable terms as a s</p> <p>Parameters:</p> Name Type Description Default <code>size(float)</code> <p>Size in Bytes</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>a String representation</p> Source code in <code>expirebackups/expire.py</code> <pre><code>@classmethod\ndef getSizeString(cls, size: float) -&gt; str:\n    \"\"\"\n    get my Size in human readable terms as a s\n\n    Args:\n        size(float): Size in Bytes\n\n    Returns:\n        str: a String representation\n    \"\"\"\n    size, unit, _factor = cls.getSize(size)\n    text = f\"{size:5.0f} {unit}\"\n    return text\n</code></pre>"},{"location":"#expirebackups.expire.BackupFile.getStats","title":"<code>getStats()</code>","text":"<p>get the datetime when the file was modified</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>Tuple[datetime, float]</code> <p>the file modification time</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getStats(self) -&gt; Tuple[datetime.datetime, float]:\n    \"\"\"\n    get the datetime when the file was modified\n\n    Returns:\n        datetime: the file modification time\n    \"\"\"\n    stats = os.stat(self.filePath)\n    modified = datetime.datetime.fromtimestamp(stats.st_mtime, tz=datetime.timezone.utc)\n    size = stats.st_size\n    return modified, size\n</code></pre>"},{"location":"#expirebackups.expire.Expiration","title":"<code>Expiration</code>","text":"<p>Expiration pattern</p> Source code in <code>expirebackups/expire.py</code> <pre><code>class Expiration:\n    \"\"\"\n    Expiration pattern\n    \"\"\"\n\n    def __init__(\n        self,\n        days: int = defaultDays,\n        weeks: int = defaultWeeks,\n        months: int = defaultMonths,\n        years: int = defaultYears,\n        minFileSize: int = defaultMinFileSize,\n        debug: bool = False,\n    ):\n        \"\"\"\n        constructor\n\n        Args:\n            days(float): how many files to keep for the daily backup\n            weeks(float): how many files to keep for the weekly backup\n            months(float): how many files to keep for the monthly backup\n            years(float):  how many files to keep for the yearly backup\n            debug(bool): if true show debug information (rule application)\n        \"\"\"\n        self.rules = {\n            \"dayly\": ExpirationRule(\"days\", 1.0, days),\n            \"weekly\": ExpirationRule(\"weeks\", 7.0, weeks),\n            # the month is in fact 4 weeks\n            \"monthly\": ExpirationRule(\"months\", 28.0, months),\n            # the year is in fact 52 weeks or 13 of the 4 week months\n            \"yearly\": ExpirationRule(\"years\", 364.0, years),\n        }\n        self.minFileSize = minFileSize\n        self.debug = debug\n\n    def getNextRule(self, ruleIter, prevFile: BackupFile, verbose: bool) -&gt; ExpirationRule:\n        \"\"\"\n        get the next rule for the given ruleIterator\n\n        Args:\n            ruleIter(Iter): Iterator over ExpirationRules\n            prevFile(BackupFile): the previousFile to take into account / reset/anchor the rule with\n            verbose(bool): if True show a message that the rule will be applied\n        Returns:\n            ExpirationRule: the next ExpirationRule\n        \"\"\"\n        ruleKey = next(ruleIter)\n        rule = self.rules[ruleKey]\n        rule.ruleName = ruleKey\n        if verbose:\n            print(f\"keeping {rule.minAmount} files for {rule.ruleName} backup\")\n        rule.reset(prevFile)\n        return rule\n\n    def applyRules(self, backupFiles: list, verbose: bool = True):\n        \"\"\"\n        apply my expiration rules to the given list of\n        backup Files\n\n        Args:\n            backupFiles(list): the list of backupFiles to apply the rules to\n            verbose(debug): if true show what the rules are doing\n        Returns:\n            list: the sorted and marked list of backupFiles\n        \"\"\"\n        filesByAge = sorted(backupFiles, key=lambda backupFile: backupFile.getAgeInDays())\n        ruleIter = iter(self.rules)\n        rule = self.getNextRule(ruleIter, None, verbose)\n        prevFile = None\n        for file in filesByAge:\n            if file.size &lt; self.minFileSize:\n                file.expire = True\n            else:\n                ruleDone = rule.apply(file, prevFile, debug=self.debug)\n                if not file.expire:\n                    prevFile = file\n                if ruleDone:\n                    rule = self.getNextRule(ruleIter, prevFile, verbose)\n        return filesByAge\n</code></pre>"},{"location":"#expirebackups.expire.Expiration.__init__","title":"<code>__init__(days=defaultDays, weeks=defaultWeeks, months=defaultMonths, years=defaultYears, minFileSize=defaultMinFileSize, debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>days(float)</code> <p>how many files to keep for the daily backup</p> required <code>weeks(float)</code> <p>how many files to keep for the weekly backup</p> required <code>months(float)</code> <p>how many files to keep for the monthly backup</p> required <code>years(float)</code> <p>how many files to keep for the yearly backup</p> required <code>debug(bool)</code> <p>if true show debug information (rule application)</p> required Source code in <code>expirebackups/expire.py</code> <pre><code>def __init__(\n    self,\n    days: int = defaultDays,\n    weeks: int = defaultWeeks,\n    months: int = defaultMonths,\n    years: int = defaultYears,\n    minFileSize: int = defaultMinFileSize,\n    debug: bool = False,\n):\n    \"\"\"\n    constructor\n\n    Args:\n        days(float): how many files to keep for the daily backup\n        weeks(float): how many files to keep for the weekly backup\n        months(float): how many files to keep for the monthly backup\n        years(float):  how many files to keep for the yearly backup\n        debug(bool): if true show debug information (rule application)\n    \"\"\"\n    self.rules = {\n        \"dayly\": ExpirationRule(\"days\", 1.0, days),\n        \"weekly\": ExpirationRule(\"weeks\", 7.0, weeks),\n        # the month is in fact 4 weeks\n        \"monthly\": ExpirationRule(\"months\", 28.0, months),\n        # the year is in fact 52 weeks or 13 of the 4 week months\n        \"yearly\": ExpirationRule(\"years\", 364.0, years),\n    }\n    self.minFileSize = minFileSize\n    self.debug = debug\n</code></pre>"},{"location":"#expirebackups.expire.Expiration.applyRules","title":"<code>applyRules(backupFiles, verbose=True)</code>","text":"<p>apply my expiration rules to the given list of backup Files</p> <p>Parameters:</p> Name Type Description Default <code>backupFiles(list)</code> <p>the list of backupFiles to apply the rules to</p> required <code>verbose(debug)</code> <p>if true show what the rules are doing</p> required <p>Returns:     list: the sorted and marked list of backupFiles</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def applyRules(self, backupFiles: list, verbose: bool = True):\n    \"\"\"\n    apply my expiration rules to the given list of\n    backup Files\n\n    Args:\n        backupFiles(list): the list of backupFiles to apply the rules to\n        verbose(debug): if true show what the rules are doing\n    Returns:\n        list: the sorted and marked list of backupFiles\n    \"\"\"\n    filesByAge = sorted(backupFiles, key=lambda backupFile: backupFile.getAgeInDays())\n    ruleIter = iter(self.rules)\n    rule = self.getNextRule(ruleIter, None, verbose)\n    prevFile = None\n    for file in filesByAge:\n        if file.size &lt; self.minFileSize:\n            file.expire = True\n        else:\n            ruleDone = rule.apply(file, prevFile, debug=self.debug)\n            if not file.expire:\n                prevFile = file\n            if ruleDone:\n                rule = self.getNextRule(ruleIter, prevFile, verbose)\n    return filesByAge\n</code></pre>"},{"location":"#expirebackups.expire.Expiration.getNextRule","title":"<code>getNextRule(ruleIter, prevFile, verbose)</code>","text":"<p>get the next rule for the given ruleIterator</p> <p>Parameters:</p> Name Type Description Default <code>ruleIter(Iter)</code> <p>Iterator over ExpirationRules</p> required <code>prevFile(BackupFile)</code> <p>the previousFile to take into account / reset/anchor the rule with</p> required <code>verbose(bool)</code> <p>if True show a message that the rule will be applied</p> required <p>Returns:     ExpirationRule: the next ExpirationRule</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getNextRule(self, ruleIter, prevFile: BackupFile, verbose: bool) -&gt; ExpirationRule:\n    \"\"\"\n    get the next rule for the given ruleIterator\n\n    Args:\n        ruleIter(Iter): Iterator over ExpirationRules\n        prevFile(BackupFile): the previousFile to take into account / reset/anchor the rule with\n        verbose(bool): if True show a message that the rule will be applied\n    Returns:\n        ExpirationRule: the next ExpirationRule\n    \"\"\"\n    ruleKey = next(ruleIter)\n    rule = self.rules[ruleKey]\n    rule.ruleName = ruleKey\n    if verbose:\n        print(f\"keeping {rule.minAmount} files for {rule.ruleName} backup\")\n    rule.reset(prevFile)\n    return rule\n</code></pre>"},{"location":"#expirebackups.expire.ExpirationRule","title":"<code>ExpirationRule</code>","text":"<p>an expiration rule keeps files at a certain</p> Source code in <code>expirebackups/expire.py</code> <pre><code>class ExpirationRule:\n    \"\"\"\n    an expiration rule keeps files at a certain\n    \"\"\"\n\n    def __init__(self, name, freq: float, minAmount: int):\n        \"\"\"\n        constructor\n\n        name(str): name of this rule\n        freq(float): the frequency) in days\n        minAmount(int): the minimum of files to keep around\n        \"\"\"\n        self.name = name\n        self.ruleName = name  # will late be changed by a sideEffect in getNextRule e.g. from \"week\" to \"weekly\"\n        self.freq = freq\n        self.minAmount = minAmount\n        if minAmount &lt; 0:\n            raise Exception(f\"{self.minAmount} {self.name} is invalid - {self.name} must be &gt;=0\")\n\n    def reset(self, prevFile: BackupFile):\n        \"\"\"\n        reset my state with the given previous File\n\n        Args:\n            prevFile: BackupFile - the file to anchor my startAge with\n        \"\"\"\n        self.kept = 0\n        if prevFile is None:\n            self.startAge = 0\n        else:\n            self.startAge = prevFile.ageInDays\n\n    def apply(self, file: BackupFile, prevFile: BackupFile, debug: bool) -&gt; bool:\n        \"\"\"\n        apply me to the given file taking the previously kept File prevFile (which might be None) into account\n\n        Args:\n\n            file(BackupFile): the file to apply this rule for\n            prevFile(BackupFile): the previous file to potentially take into account\n            debug(bool): if True show debug output\n        \"\"\"\n        if prevFile is not None:\n            ageDiff = file.ageInDays - prevFile.ageInDays\n            keep = ageDiff &gt;= self.freq\n        else:\n            ageDiff = file.ageInDays - self.startAge\n            keep = True\n        if keep:\n            self.kept += 1\n        else:\n            file.expire = True\n        if debug:\n            print(\n                f\"\u0394 {ageDiff}({ageDiff-self.freq}) days for {self.ruleName}({self.freq}) {self.kept}/{self.minAmount}{file}\"\n            )\n        return self.kept &gt;= self.minAmount\n</code></pre>"},{"location":"#expirebackups.expire.ExpirationRule.__init__","title":"<code>__init__(name, freq, minAmount)</code>","text":"<p>constructor</p> <p>name(str): name of this rule freq(float): the frequency) in days minAmount(int): the minimum of files to keep around</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def __init__(self, name, freq: float, minAmount: int):\n    \"\"\"\n    constructor\n\n    name(str): name of this rule\n    freq(float): the frequency) in days\n    minAmount(int): the minimum of files to keep around\n    \"\"\"\n    self.name = name\n    self.ruleName = name  # will late be changed by a sideEffect in getNextRule e.g. from \"week\" to \"weekly\"\n    self.freq = freq\n    self.minAmount = minAmount\n    if minAmount &lt; 0:\n        raise Exception(f\"{self.minAmount} {self.name} is invalid - {self.name} must be &gt;=0\")\n</code></pre>"},{"location":"#expirebackups.expire.ExpirationRule.apply","title":"<code>apply(file, prevFile, debug)</code>","text":"<p>apply me to the given file taking the previously kept File prevFile (which might be None) into account</p> <p>Args:</p> <pre><code>file(BackupFile): the file to apply this rule for\nprevFile(BackupFile): the previous file to potentially take into account\ndebug(bool): if True show debug output\n</code></pre> Source code in <code>expirebackups/expire.py</code> <pre><code>def apply(self, file: BackupFile, prevFile: BackupFile, debug: bool) -&gt; bool:\n    \"\"\"\n    apply me to the given file taking the previously kept File prevFile (which might be None) into account\n\n    Args:\n\n        file(BackupFile): the file to apply this rule for\n        prevFile(BackupFile): the previous file to potentially take into account\n        debug(bool): if True show debug output\n    \"\"\"\n    if prevFile is not None:\n        ageDiff = file.ageInDays - prevFile.ageInDays\n        keep = ageDiff &gt;= self.freq\n    else:\n        ageDiff = file.ageInDays - self.startAge\n        keep = True\n    if keep:\n        self.kept += 1\n    else:\n        file.expire = True\n    if debug:\n        print(\n            f\"\u0394 {ageDiff}({ageDiff-self.freq}) days for {self.ruleName}({self.freq}) {self.kept}/{self.minAmount}{file}\"\n        )\n    return self.kept &gt;= self.minAmount\n</code></pre>"},{"location":"#expirebackups.expire.ExpirationRule.reset","title":"<code>reset(prevFile)</code>","text":"<p>reset my state with the given previous File</p> <p>Parameters:</p> Name Type Description Default <code>prevFile</code> <code>BackupFile</code> <p>BackupFile - the file to anchor my startAge with</p> required Source code in <code>expirebackups/expire.py</code> <pre><code>def reset(self, prevFile: BackupFile):\n    \"\"\"\n    reset my state with the given previous File\n\n    Args:\n        prevFile: BackupFile - the file to anchor my startAge with\n    \"\"\"\n    self.kept = 0\n    if prevFile is None:\n        self.startAge = 0\n    else:\n        self.startAge = prevFile.ageInDays\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups","title":"<code>ExpireBackups</code>","text":"<p>               Bases: <code>object</code></p> <p>Expiration of Backups - migrated from com.bitplan.backup java solution</p> Source code in <code>expirebackups/expire.py</code> <pre><code>class ExpireBackups(object):\n    \"\"\"\n    Expiration of Backups - migrated from com.bitplan.backup java solution\n    \"\"\"\n\n    def __init__(\n        self,\n        rootPath: str,\n        baseName: str = None,\n        ext: str = None,\n        expiration: Expiration = None,\n        dryRun: bool = True,\n        debug: bool = False,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            rootPath(str): the base path for this backup expiration\n            baseName(str): the basename to filter for (if any)\n            ext(str): file extensions to filter for e.g. \".tgz\" (if any)\n            expiration(Expiration): the Expiration Rules to apply\n            dryRun(bool): donot delete any files but only show deletion plan\n        \"\"\"\n        self.rootPath = rootPath\n        self.baseName = baseName\n        self.ext = ext\n        # if no expiration is specified use the default one\n        if expiration is None:\n            expiration = Expiration()\n        self.expiration = expiration\n        self.dryRun = dryRun\n        self.debug = debug\n\n    @classmethod\n    def createTestFile(cls, ageInDays: float, baseName: str = None, ext: str = \".tst\"):\n        \"\"\"\n        create a test File with the given extension and the given age in Days\n\n        Args:\n            ageInDays(float): the age of the file in days\n            baseName(str): the prefix of the files (default: None)\n            ext(str): the extension to be used - default \".tst\"\n\n        Returns:\n            str: the full path name of the testfile\n        \"\"\"\n        now = datetime.datetime.now(tz=datetime.timezone.utc)\n        dayDelta = datetime.timedelta(days=ageInDays)\n        wantedTime = now - dayDelta\n        timestamp = datetime.datetime.timestamp(wantedTime)\n        prefix = \"\" if baseName is None else f\"{baseName}-\"\n        testFile = NamedTemporaryFile(prefix=f\"{prefix}{ageInDays}daysOld-\", suffix=ext, delete=False)\n        with open(testFile.name, \"a\"):\n            times = (timestamp, timestamp)  # access time and modification time\n            os.utime(testFile.name, times)\n        return testFile.name\n\n    @classmethod\n    def createTestFiles(cls, numberOfTestfiles: int, baseName: str = \"expireBackupTest\", ext: str = \".tst\"):\n        \"\"\"\n        create the given number of tests files\n\n        Args:\n            numberOfTestfiles(int): the number of files to create\n            baseName(str): the prefix of the files (default: '')\n            ext(str): the extension of the files (default: '.tst')\n\n        Returns:\n            tuple(str,list): the path of the directory where the test files have been created\n            and a list of BackupFile files\n        \"\"\"\n        backupFiles = []\n        for ageInDays in range(1, numberOfTestfiles + 1):\n            testFile = ExpireBackups.createTestFile(ageInDays, baseName=baseName, ext=ext)\n            backupFiles.append(BackupFile(testFile))\n        path = pathlib.Path(testFile).parent.resolve()\n        return path, backupFiles\n\n    def getBackupFiles(self) -&gt; list:\n        \"\"\"\n        get the list of my backup Files\n        \"\"\"\n        backupFiles = []\n        for root, _dirs, files in os.walk(self.rootPath):\n            for file in files:\n                include = False\n                if self.baseName is not None:\n                    include = file.startswith(self.baseName)\n                if self.ext is not None:\n                    include = file.endswith(self.ext)\n                if include:\n                    backupFile = BackupFile(os.path.join(root, file))\n                    backupFiles.append(backupFile)\n        return backupFiles\n\n    def doexpire(self, withDelete: bool = False, show=True, showLimit: int = None):\n        \"\"\"\n        expire the files in the given rootPath\n\n        withDelete(bool): if True really delete the files\n        show(bool): if True show the expiration plan\n        showLimit(int): if set limit the number of lines to display\n        \"\"\"\n        backupFiles = self.getBackupFiles()\n        filesByAge = self.expiration.applyRules(backupFiles)\n        total = 0\n        keptTotal = 0\n        kept = 0\n        if show:\n            deletehint = \"by deletion\" if withDelete else \"dry run\"\n            print(f\"expiring {len(filesByAge)} files {deletehint}\")\n        for i, backupFile in enumerate(filesByAge):\n            total += backupFile.size\n            totalString = BackupFile.getSizeString(total)\n            marker = backupFile.getMarker()\n            line = f\"#{i+1:4d}{marker}:{backupFile.ageInDays:6.1f} days({backupFile.sizeString}/{totalString})\u2192{backupFile.filePath}\"\n            showLine = show and showLimit is None or i &lt; showLimit\n            if showLine:\n                print(line)\n            if not backupFile.expire:\n                kept += 1\n                keptTotal += backupFile.size\n            if withDelete and backupFile.expire:\n                backupFile.delete()\n        if show:\n            keptSizeString = BackupFile.getSizeString(keptTotal)\n            print(f\"kept {kept} files {keptSizeString}\")\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups.__init__","title":"<code>__init__(rootPath, baseName=None, ext=None, expiration=None, dryRun=True, debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>rootPath(str)</code> <p>the base path for this backup expiration</p> required <code>baseName(str)</code> <p>the basename to filter for (if any)</p> required <code>ext(str)</code> <p>file extensions to filter for e.g. \".tgz\" (if any)</p> required <code>expiration(Expiration)</code> <p>the Expiration Rules to apply</p> required <code>dryRun(bool)</code> <p>donot delete any files but only show deletion plan</p> required Source code in <code>expirebackups/expire.py</code> <pre><code>def __init__(\n    self,\n    rootPath: str,\n    baseName: str = None,\n    ext: str = None,\n    expiration: Expiration = None,\n    dryRun: bool = True,\n    debug: bool = False,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        rootPath(str): the base path for this backup expiration\n        baseName(str): the basename to filter for (if any)\n        ext(str): file extensions to filter for e.g. \".tgz\" (if any)\n        expiration(Expiration): the Expiration Rules to apply\n        dryRun(bool): donot delete any files but only show deletion plan\n    \"\"\"\n    self.rootPath = rootPath\n    self.baseName = baseName\n    self.ext = ext\n    # if no expiration is specified use the default one\n    if expiration is None:\n        expiration = Expiration()\n    self.expiration = expiration\n    self.dryRun = dryRun\n    self.debug = debug\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups.createTestFile","title":"<code>createTestFile(ageInDays, baseName=None, ext='.tst')</code>  <code>classmethod</code>","text":"<p>create a test File with the given extension and the given age in Days</p> <p>Parameters:</p> Name Type Description Default <code>ageInDays(float)</code> <p>the age of the file in days</p> required <code>baseName(str)</code> <p>the prefix of the files (default: None)</p> required <code>ext(str)</code> <p>the extension to be used - default \".tst\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the full path name of the testfile</p> Source code in <code>expirebackups/expire.py</code> <pre><code>@classmethod\ndef createTestFile(cls, ageInDays: float, baseName: str = None, ext: str = \".tst\"):\n    \"\"\"\n    create a test File with the given extension and the given age in Days\n\n    Args:\n        ageInDays(float): the age of the file in days\n        baseName(str): the prefix of the files (default: None)\n        ext(str): the extension to be used - default \".tst\"\n\n    Returns:\n        str: the full path name of the testfile\n    \"\"\"\n    now = datetime.datetime.now(tz=datetime.timezone.utc)\n    dayDelta = datetime.timedelta(days=ageInDays)\n    wantedTime = now - dayDelta\n    timestamp = datetime.datetime.timestamp(wantedTime)\n    prefix = \"\" if baseName is None else f\"{baseName}-\"\n    testFile = NamedTemporaryFile(prefix=f\"{prefix}{ageInDays}daysOld-\", suffix=ext, delete=False)\n    with open(testFile.name, \"a\"):\n        times = (timestamp, timestamp)  # access time and modification time\n        os.utime(testFile.name, times)\n    return testFile.name\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups.createTestFiles","title":"<code>createTestFiles(numberOfTestfiles, baseName='expireBackupTest', ext='.tst')</code>  <code>classmethod</code>","text":"<p>create the given number of tests files</p> <p>Parameters:</p> Name Type Description Default <code>numberOfTestfiles(int)</code> <p>the number of files to create</p> required <code>baseName(str)</code> <p>the prefix of the files (default: '')</p> required <code>ext(str)</code> <p>the extension of the files (default: '.tst')</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(str, list)</code> <p>the path of the directory where the test files have been created</p> <p>and a list of BackupFile files</p> Source code in <code>expirebackups/expire.py</code> <pre><code>@classmethod\ndef createTestFiles(cls, numberOfTestfiles: int, baseName: str = \"expireBackupTest\", ext: str = \".tst\"):\n    \"\"\"\n    create the given number of tests files\n\n    Args:\n        numberOfTestfiles(int): the number of files to create\n        baseName(str): the prefix of the files (default: '')\n        ext(str): the extension of the files (default: '.tst')\n\n    Returns:\n        tuple(str,list): the path of the directory where the test files have been created\n        and a list of BackupFile files\n    \"\"\"\n    backupFiles = []\n    for ageInDays in range(1, numberOfTestfiles + 1):\n        testFile = ExpireBackups.createTestFile(ageInDays, baseName=baseName, ext=ext)\n        backupFiles.append(BackupFile(testFile))\n    path = pathlib.Path(testFile).parent.resolve()\n    return path, backupFiles\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups.doexpire","title":"<code>doexpire(withDelete=False, show=True, showLimit=None)</code>","text":"<p>expire the files in the given rootPath</p> <p>withDelete(bool): if True really delete the files show(bool): if True show the expiration plan showLimit(int): if set limit the number of lines to display</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def doexpire(self, withDelete: bool = False, show=True, showLimit: int = None):\n    \"\"\"\n    expire the files in the given rootPath\n\n    withDelete(bool): if True really delete the files\n    show(bool): if True show the expiration plan\n    showLimit(int): if set limit the number of lines to display\n    \"\"\"\n    backupFiles = self.getBackupFiles()\n    filesByAge = self.expiration.applyRules(backupFiles)\n    total = 0\n    keptTotal = 0\n    kept = 0\n    if show:\n        deletehint = \"by deletion\" if withDelete else \"dry run\"\n        print(f\"expiring {len(filesByAge)} files {deletehint}\")\n    for i, backupFile in enumerate(filesByAge):\n        total += backupFile.size\n        totalString = BackupFile.getSizeString(total)\n        marker = backupFile.getMarker()\n        line = f\"#{i+1:4d}{marker}:{backupFile.ageInDays:6.1f} days({backupFile.sizeString}/{totalString})\u2192{backupFile.filePath}\"\n        showLine = show and showLimit is None or i &lt; showLimit\n        if showLine:\n            print(line)\n        if not backupFile.expire:\n            kept += 1\n            keptTotal += backupFile.size\n        if withDelete and backupFile.expire:\n            backupFile.delete()\n    if show:\n        keptSizeString = BackupFile.getSizeString(keptTotal)\n        print(f\"kept {kept} files {keptSizeString}\")\n</code></pre>"},{"location":"#expirebackups.expire.ExpireBackups.getBackupFiles","title":"<code>getBackupFiles()</code>","text":"<p>get the list of my backup Files</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def getBackupFiles(self) -&gt; list:\n    \"\"\"\n    get the list of my backup Files\n    \"\"\"\n    backupFiles = []\n    for root, _dirs, files in os.walk(self.rootPath):\n        for file in files:\n            include = False\n            if self.baseName is not None:\n                include = file.startswith(self.baseName)\n            if self.ext is not None:\n                include = file.endswith(self.ext)\n            if include:\n                backupFile = BackupFile(os.path.join(root, file))\n                backupFiles.append(backupFile)\n    return backupFiles\n</code></pre>"},{"location":"#expirebackups.expire.main","title":"<code>main(argv=None)</code>","text":"<p>main program.</p> Source code in <code>expirebackups/expire.py</code> <pre><code>def main(argv=None):  # IGNORE:C0111\n    \"\"\"main program.\"\"\"\n\n    if argv is None:\n        argv = sys.argv\n\n    program_name = os.path.basename(sys.argv[0])\n    program_version = \"v%s\" % __version__\n    program_build_date = str(__updated__)\n    program_version_message = \"%%(prog)s %s (%s)\" % (program_version, program_build_date)\n    program_shortdesc = Version.description\n    user_name = \"Wolfgang Fahl\"\n    program_license = \"\"\"%s\n\n  Created by %s on %s.\n  Copyright 2008-2022 Wolfgang Fahl. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\n\nUSAGE\n\"\"\" % (\n        program_shortdesc,\n        user_name,\n        str(__date__),\n    )\n\n    try:\n        # Setup argument parser\n        parser = ArgumentParser(description=program_license, formatter_class=RawDescriptionHelpFormatter)\n        parser.add_argument(\"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\")\n\n        # expiration schedule selection\n        parser.add_argument(\n            \"--days\",\n            type=int,\n            default=defaultDays,\n            help=\"number of consecutive days to keep a daily backup (default: %(default)s)\",\n        )\n        parser.add_argument(\n            \"--weeks\",\n            type=int,\n            default=defaultWeeks,\n            help=\"number of consecutive weeks to keep a weekly backup (default: %(default)s)\",\n        )\n        parser.add_argument(\n            \"--months\",\n            type=int,\n            default=defaultMonths,\n            help=\"number of consecutive month to keep a monthly backup (default: %(default)s)\",\n        )\n        parser.add_argument(\n            \"--years\",\n            type=int,\n            default=defaultYears,\n            help=\"number of consecutive years to keep a yearly backup (default: %(default)s)\",\n        )\n\n        # file filter selection arguments\n        parser.add_argument(\n            \"--minFileSize\",\n            type=int,\n            default=defaultMinFileSize,\n            help=\"minimum File size in bytes to filter for (default: %(default)s)\",\n        )\n        parser.add_argument(\"--rootPath\", default=\".\")\n        parser.add_argument(\"--baseName\", default=None, help=\"the basename to filter for (default: %(default)s)\")\n        parser.add_argument(\"--ext\", default=None, help=\"the extension to filter for (default: %(default)s)\")\n\n        parser.add_argument(\n            \"--createTestFiles\",\n            type=int,\n            default=None,\n            help=\"create the given number of temporary test files (default: %(default)s)\",\n        )\n\n        parser.add_argument(\"-f\", \"--force\", action=\"store_true\")\n        parser.add_argument(\"-V\", \"--version\", action=\"version\", version=program_version_message)\n\n        args = parser.parse_args(argv[1:])\n        if args.createTestFiles:\n            path, _backupFiles = ExpireBackups.createTestFiles(args.createTestFiles)\n            print(f\"created {args.createTestFiles} test files with extension '.tst' in {path}\")\n            print(\n                f\"Please try out \\nexpireBackups --rootPath {path} --baseName expireBackup --ext .tst --minFileSize 0\"\n            )\n            print(\n                \"then try appending the -f option to the command that will actually delete files (which are in a temporary directory\"\n            )\n            print(\n                \"and run the command another time with that option to see that no files are deleted any more on second run\"\n            )\n        else:\n            dryRun = True\n            if args.force:\n                dryRun = False\n            expiration = Expiration(\n                days=args.days,\n                months=args.months,\n                weeks=args.weeks,\n                years=args.years,\n                minFileSize=args.minFileSize,\n                debug=args.debug,\n            )\n            eb = ExpireBackups(\n                rootPath=args.rootPath,\n                baseName=args.baseName,\n                ext=args.ext,\n                expiration=expiration,\n                dryRun=dryRun,\n                debug=args.debug,\n            )\n            eb.doexpire(args.force)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#expirebackups.version","title":"<code>version</code>","text":"<p>Created on 2022-04-01</p> <p>@author: wf</p>"},{"location":"#expirebackups.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyExpireBackups</p> Source code in <code>expirebackups/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyExpireBackups\n    \"\"\"\n\n    name = \"pyExpireBackups\"\n    description = \"Backup expiration based on rules (yearly,monthly,weekly,daily ...)\"\n    version = \"0.1.0\"\n    date = \"2022-04-01\"\n    updated = \"2025-10-16\"\n</code></pre>"}]}